
'''
❓ PROMPT
Given a square matrix *mat*, return the sum of the matrix diagonals.

Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal *that are not part of the primary diagonal*.

Example(s)
Input:
[[1,2,3],
 [4,5,6],
 [7,8,9]]
Output: 25
Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Element mat[1][1] = 5 is counted only once.

Input:
[[1,1,1,1], 0,3 where 3 is len(matrix[0]) - (i+1)
 [1,1,1,1], 1,2 where 2 is len(matrix[0]) - (i+1)
 [1,1,1,1],
 [1,1,1,1]]
Output: 8

Input: [[5]]
Output: 5
 

🔎 EXPLORE
List your assumptions & discoveries:
do not count middle
will not have non square


Insightful & revealing test cases:
single element

🧠 BRAINSTORM
What approaches could work?
Algorithm 1:
Time: O()
Space: O()
 

📆 PLAN
Outline of algorithm #: 

init result
for each row:
    for each element in the row:


 
'''
# 🛠️ IMPLEMENT
# function diagonalSum(matrix) {
# def diagonalSum(matrix: list[list[int]]) -> int:

def diagonalSum(matrix: list[list[int]]) -> int:
    result = 0

    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            if i == j:
                result += matrix[i][j]
            if j == (len(matrix[0]) - (i+1)) and i!=j:
                result += matrix[i][j]

    return result
 

# 🧪 VERIFY
# Run tests. Methodically debug & analyze issues.
mat = [[1,2,3],
       [4,5,6],
       [7,8,9]]
print(diagonalSum(mat) == 25)

mat = [[1,1,1,1],
       [1,1,1,1],
       [1,1,1,1],
       [1,1,1,1]]
print(diagonalSum(mat) == 8)

mat = [[5]]
print(diagonalSum(mat) == 5)

mat = []
print(diagonalSum(mat) == 0)
